var winston = require('winston');
var util = require('util');
var fs = require('fs');
var path = require('path');
var _ = require('underscore');
require('cloud-mysqltransport');

/**
 * A default list of properties in the request object that are allowed to be logged.
 * These properties will be safely included in the meta of the log.
 * 'body' is not included in this list because it can contains passwords and stuff that are sensitive for logging.
 * TODO: Include 'body' and get the defaultRequestFilter to filter the inner properties like 'password' or 'password_confirmation', etc. Pull requests anyone?
 * @type {Array}
 */
var requestWhitelist = ['headers', 'method', 'httpVersion', 'originalUrl', 'sessionID'];

/**
 * A default list of properties in the request body that are allowed to be logged.
 * This will normally be empty here, since it should be done at the route level.
 * @type {Array}
 */
var bodyWhitelist = [];

/**
 * A default list of properties in the response object that are allowed to be logged.
 * These properties will be safely included in the meta of the log.
 * @type {Array}
 */
var responseWhitelist = ['responseTime', 'statusCode'];

/**
 * A default function to filter the properties of the req object.
 * @param req
 * @param propName
 * @return {*}
 */
var defaultRequestFilter = function (req, propName) {
    return req[propName];
};

/**
 * A default function to filter the properties of the res object.
 * @param res
 * @param propName
 * @return {*}
 */
var defaultResponseFilter = function (req, propName) {
    return req[propName];
};

function filterObject(originalObj, whiteList, initialFilter) {

    var obj = {};

    [].concat(whiteList).forEach(function (propName) {
        var value = initialFilter(originalObj, propName);

        if(typeof (value) !== 'undefined') {
            obj[propName] = value;
        };
    });

    return obj;
}


var tbsql = '` ('
    + '`logId` bigint(20) unsigned NOT NULL AUTO_INCREMENT,'
    + '`timestamp` datetime DEFAULT NULL,'
    + '`logType` int(11) DEFAULT NULL,'
    + '`host` varchar(60) DEFAULT NULL,'
    + '`url` varchar(256) DEFAULT NULL,'
    + '`urlReferer` varchar(256) DEFAULT NULL,'
    + '`method` varchar(10) DEFAULT NULL,'
    + '`sessionID` varchar(128) DEFAULT NULL,'
    + '`clientIp` varchar(20) DEFAULT NULL,'
    + '`statusCode` int(11) DEFAULT NULL,'
    + '`responseTime` int(11) DEFAULT NULL,'
    + '`userAgent` varchar(128) DEFAULT NULL,'
    + '`description` varchar(4000) DEFAULT NULL,'
    + 'PRIMARY KEY (`logId`)'
    + ') ENGINE=InnoDB DEFAULT CHARSET=utf8';


function errorLogger(options) {
    return function (err, req, res, next) {
        var exceptionMeta = winston.exception.getAllInfo(err);
        exceptionMeta.req = filterObject(req, requestWhitelist, defaultRequestFilter);
        exceptionMeta.req.clientIp =req.socket &&
            (req.headers['x-forwarded-for'] || req.headers['x-real-ip'] || req.socket.remoteAddress || (req.socket.socket && req.socket.socket.remoteAddress));
        exceptionMeta.logType = 3;

        var logger = new (winston.Logger)({
            transports: [
                new winston.transports.Console({colorize: true}),
               // , new winston.transports.mysqlLogger({
               //     dbsettings:  options.dbsettings
               //     , logDbName: options.logDbName
               //     , handleExceptions: true
               // })
            ]
        });

        var logmeta = {
            timestamp : new Date(),
            logType: 3,
            host: exceptionMeta.req.headers.host,
            url: exceptionMeta.req.originalUrl,
            urlReferer: exceptionMeta.req.headers.referer,
            method: exceptionMeta.req.method,
            sessionID: exceptionMeta.req.sessionID,
            clientIp: exceptionMeta.req.clientIp,
            statusCode: exceptionMeta.logType ==3? 500: exceptionMeta.res.statusCode,
            responseTime: exceptionMeta.logType ==3? 0: exceptionMeta.res.responseTime,
            userAgent: exceptionMeta.req.headers["user-agent"],
            description: exceptionMeta.stack.join('\n')
        };

        //var logger = new (winston.Logger)({
        //    transports: [
        //        new winston.transports.Console({colorize: true}),
        //        , new winston.transports.mysqlLogger({
        //            dbsettings:  options.dbsettings
        //            ,logDbName: options.logDbName
        //            ,handleExceptions: true
        //            ,tableName: 'nodeExpressLog'
        //            ,createTbSql: tbsql
        //            ,isDaily: true
        //        })
        //    ]
        //});

        logger.log('error', 'exception caught', logmeta, function () {});
        next(err);
    };
}

function logger(options) {
    return function (req, res, next) {
        var rootDir = __dirname;
        if(rootDir.indexOf("node_modules") != -1){
            rootDir = rootDir.substring(0, rootDir.indexOf("node_modules"));
        }
        var files = fs.readdirSync(path.join(rootDir, 'public'));
        for(var i= 0, len= files.length; i< len; i++){
            if(req.url.toLowerCase().indexOf('/' + files[i].toLowerCase() + '/') == 0){
                return next();
            }
        }

        req._startTime = (new Date);

        req._routeWhitelists = {
            req: [],
            res: [],
            body: []
        };

        // Manage to get information from the response too, just like Connect.logger does:
        var end = res.end;
        res.end = function(chunk, encoding) {
            res.responseTime = (new Date) - req._startTime;

            res.end = end;
            res.end(chunk, encoding);


            var meta = {};

            var bodyWhitelist;

            requestWhitelist = requestWhitelist.concat(req._routeWhitelists.req || []);
            responseWhitelist = responseWhitelist.concat(req._routeWhitelists.res || []);

            meta.req = filterObject(req, requestWhitelist, defaultRequestFilter);
            meta.res = filterObject(res, responseWhitelist, defaultResponseFilter);
            meta.req.clientIp =req.socket &&
                (req.headers['x-forwarded-for'] || req.headers['x-real-ip'] || req.socket.remoteAddress || (req.socket.socket && req.socket.socket.remoteAddress));

            bodyWhitelist = req._routeWhitelists.body || [];

            if (bodyWhitelist) {
                meta.req.body = filterObject(req.body, bodyWhitelist, defaultRequestFilter);
            };

            meta.responseTime = res.responseTime;


            // Using mustache style templating
            _.templateSettings = {
                interpolate: /\{\{(.+?)\}\}/g
            };
            var template = _.template("HTTP {{req.method}} {{req.url}}");
            var msg = template({req: req, res: res});

            var logmeta = {
                timestamp : new Date(),
                logType: 0,
                host: meta.req.headers.host,
                url: meta.req.originalUrl,
                urlReferer: meta.req.headers.referer,
                method: meta.req.method,
                sessionID: meta.req.sessionID,
                clientIp: meta.req.clientIp,
                statusCode: meta.logType ==3? 500: meta.res.statusCode,
                responseTime: meta.logType ==3? 0: meta.res.responseTime,
                userAgent: meta.req.headers["user-agent"],
                description: msg
            };

            var logger = new (winston.Logger)({
                transports: [
                    new winston.transports.Console({colorize: true}),
                   // , new winston.transports.mysqlLogger({
                   //     dbsettings:  options.dbsettings
                   //     ,logDbName: options.logDbName
                   //     ,handleExceptions: true
                   //     ,tableName: 'nodeExpressLog'
                   //     ,createTbSql: tbsql
                   //     ,isDaily: true
                   // })
                ]
            });

            logger.log("info", msg, logmeta, function () {});
        };

        next();
    };
}

function ensureValidOptions(options) {
    if(!options) throw new Error("options are required by express-winston middleware");
    if(!options.transports || !(options.transports.length > 0)) throw new Error("transports are required by express-winston middleware");
};


exports.errorLogger = errorLogger;
exports.logger = logger;
exports.requestWhitelist = requestWhitelist;
exports.bodyWhitelist = bodyWhitelist;
exports.responseWhitelist = responseWhitelist;
exports.defaultRequestFilter = defaultRequestFilter;
exports.defaultResponseFilter = defaultResponseFilter;
